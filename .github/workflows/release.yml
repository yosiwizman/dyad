# .github/workflows/release.yml
#
# Builds and publishes Windows + macOS installers to GitHub Releases.
# Triggers on version tags (v*.*.*) or manual workflow dispatch.
#
# NOTE: electron-forge creates DRAFT releases. The publish-release job
# converts the draft to a public release after all builds complete.

permissions:
  contents: write

name: Release app
on:
  push:
    tags:
      - "v*.*.*"
  workflow_dispatch:
    inputs:
      tag:
        description: "Tag to release (e.g., v0.2.8). Leave empty to use package.json version."
        required: false
        type: string

jobs:
  build:
    environment: release
    strategy:
      # max-parallel: 1 # Uncomment to prevent race condition when creating releases
      matrix:
        os:
          - { name: "windows", image: "windows-latest" }
          - { name: "macos-intel", image: "macos-15-intel" }
          - { name: "macos", image: "macos-latest" }
    runs-on: ${{ matrix.os.image }}
    steps:
      - name: Github checkout
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
      - name: Use Node.js
        uses: actions/setup-node@cdca7365b2dadb8aad0a33bc7601856ffabcc48e # v4.3.0
        with:
          node-version: 20
      - run: npm ci
        env:
          # Required for @vscode/ripgrep to download binaries without hitting GitHub API rate limits
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: add macos cert
        if: contains(matrix.os.name, 'macos')
        env:
          MACOS_CERT_P12: ${{ secrets.MACOS_CERT_P12 }}
          MACOS_CERT_PASSWORD: ${{ secrets.MACOS_CERT_PASSWORD }}
        run: |
          if [ -z "$MACOS_CERT_P12" ] || [ -z "$MACOS_CERT_PASSWORD" ]; then
            echo "macOS signing secrets not configured, skipping certificate setup"
            exit 0
          fi
          chmod +x tools/add-macos-cert.sh && . ./tools/add-macos-cert.sh
        shell: bash
      # Windows only
      - name: Set up certificate
        if: contains(matrix.os.name, 'windows')
        env:
          SM_CLIENT_CERT_FILE_B64: ${{ secrets.SM_CLIENT_CERT_FILE_B64 }}
        run: |
          if [ -z "$SM_CLIENT_CERT_FILE_B64" ]; then
            echo "Windows signing secrets not configured, skipping certificate setup"
            exit 0
          fi
          echo "$SM_CLIENT_CERT_FILE_B64" | base64 --decode > /d/Certificate_pkcs12.p12
        shell: bash
      - name: Set variables
        if: contains(matrix.os.name, 'windows')
        id: variables
        env:
          SM_HOST: ${{ secrets.SM_HOST }}
          SM_API_KEY: ${{ secrets.SM_API_KEY }}
          SM_CLIENT_CERT_PASSWORD: ${{ secrets.SM_CLIENT_CERT_PASSWORD }}
        run: |
          if [ -z "$SM_HOST" ] || [ -z "$SM_API_KEY" ] || [ -z "$SM_CLIENT_CERT_PASSWORD" ]; then
            echo "Windows signing env vars not configured, skipping"
            exit 0
          fi
          echo "SM_HOST=$SM_HOST" >> "$GITHUB_ENV" 
          echo "SM_API_KEY=$SM_API_KEY" >> "$GITHUB_ENV" 
          echo "SM_CLIENT_CERT_FILE=D:\\Certificate_pkcs12.p12" >> "$GITHUB_ENV" 
          echo "SM_CLIENT_CERT_PASSWORD=$SM_CLIENT_CERT_PASSWORD" >> "$GITHUB_ENV"
        shell: bash
      - name: Code signing with Software Trust Manager
        if: contains(matrix.os.name, 'windows') && env.SM_HOST != ''
        uses: digicert/ssm-code-signing@v1.1.0
      - name: Sync certificate (Windows)
        if: contains(matrix.os.name, 'windows')
        env:
          DIGICERT_KEYPAIR_ALIAS: ${{ secrets.DIGICERT_KEYPAIR_ALIAS }}
        run: |
          if [ -z "$DIGICERT_KEYPAIR_ALIAS" ]; then
            echo "Windows DIGICERT_KEYPAIR_ALIAS not configured, skipping certsync"
            exit 0
          fi
          smctl windows certsync --keypair-alias="$DIGICERT_KEYPAIR_ALIAS"
        shell: bash
        # Publish (all platforms)
      - name: Publish app
        env:
          DEBUG: "@electron/*,electron-forge:*,electron-windows-installer:main"
          NODE_OPTIONS: "--max-old-space-size=4096"
          SM_CODE_SIGNING_CERT_SHA1_HASH: ${{ secrets.SM_CODE_SIGNING_CERT_SHA1_HASH }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          # Vault zero-config: inject Supabase credentials at build time
          ABBA_VAULT_SUPABASE_URL: ${{ secrets.ABBA_VAULT_SUPABASE_URL }}
          ABBA_VAULT_SUPABASE_ANON_KEY: ${{ secrets.ABBA_VAULT_SUPABASE_ANON_KEY }}
        # Don't use npm run because we don't get logs
        # https://github.com/electron/forge/blob/main/SUPPORT.md
        run: ./node_modules/.bin/electron-forge publish

  publish-release:
    name: Publish Release
    needs: build
    runs-on: ubuntu-latest
    outputs:
      release_url: ${{ steps.publish.outputs.release_url }}
      tag_name: ${{ steps.get-tag.outputs.tag }}
    steps:
      - name: Github checkout
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1

      - name: Get tag name
        id: get-tag
        run: |
          if [ -n "${{ inputs.tag }}" ]; then
            TAG="${{ inputs.tag }}"
          elif [ -n "${{ github.ref_name }}" ] && [[ "${{ github.ref_name }}" == v* ]]; then
            TAG="${{ github.ref_name }}"
          else
            # Fallback to package.json version
            TAG="v$(jq -r .version package.json)"
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Using tag: $TAG"
        shell: bash

      - name: Find and publish draft release
        id: publish
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG="${{ steps.get-tag.outputs.tag }}"
          VERSION="${TAG#v}"
          echo "Looking for draft release for tag: $TAG (version: $VERSION)"

          # Find draft releases that match our version by asset names
          DRAFT_RELEASES=$(gh api repos/${{ github.repository }}/releases --jq '.[] | select(.draft == true)')

          # Find the one with matching version in asset names
          RELEASE_ID=""
          while IFS= read -r release; do
            if [ -z "$release" ]; then continue; fi
            
            # Check if any asset contains our version
            HAS_VERSION_ASSET=$(echo "$release" | jq -r ".assets[] | select(.name | contains(\"$VERSION\")) | .name" | head -1)
            if [ -n "$HAS_VERSION_ASSET" ]; then
              RELEASE_ID=$(echo "$release" | jq -r '.id')
              CURRENT_TAG=$(echo "$release" | jq -r '.tag_name')
              echo "Found draft release ID: $RELEASE_ID (current tag: $CURRENT_TAG)"
              break
            fi
          done <<< "$DRAFT_RELEASES"

          if [ -z "$RELEASE_ID" ]; then
            echo "ERROR: No draft release found with assets matching version $VERSION"
            echo "Available draft releases:"
            gh api repos/${{ github.repository }}/releases --jq '.[] | select(.draft == true) | "ID: \(.id), Tag: \(.tag_name), Assets: \([.assets[].name] | join(", "))"'
            exit 1
          fi

          # Update release: set correct tag and publish (draft: false)
          echo "Publishing release with tag: $TAG"
          gh api repos/${{ github.repository }}/releases/$RELEASE_ID \
            -X PATCH \
            -f tag_name="$TAG" \
            -f name="$TAG" \
            -F draft=false \
            -F prerelease=false

          RELEASE_URL="https://github.com/${{ github.repository }}/releases/tag/$TAG"
          echo "release_url=$RELEASE_URL" >> $GITHUB_OUTPUT
          echo "Release published: $RELEASE_URL"
        shell: bash

  verify-assets:
    name: Verify Release Assets
    needs: publish-release
    runs-on: ubuntu-latest
    steps:
      - name: Github checkout
        uses: actions/checkout@b4ffde65f46336ab88eb53be808477a3936bae11 # v4.1.1
      - name: Use Node.js
        uses: actions/setup-node@cdca7365b2dadb8aad0a33bc7601856ffabcc48e # v4.3.0
        with:
          node-version: 20
      - name: Verify all release assets are uploaded
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          EXPECTED_TAG: ${{ needs.publish-release.outputs.tag_name }}
        run: node scripts/verify-release-assets.js
